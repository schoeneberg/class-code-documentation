import re
# Input = file content (fc) as a big string
# Output = finished, polished .rst file to be directly included
def convert_explanatory(fc):
  # For now, just return dummy input independently of file contents, TODO:: implement actual logic
  pretext =  """.. _wrapper-set:

The .set() function
===================

.. function:: set(input)

  Tell classy to use certain input parameters, described in the python dictionary ``input``.
  Can also be passed as explicit keywords

  :param input: Input parameters
  :type input: dict

.. note::
  This documentation is based off of the contents of explanatory.ini and is automatically generated. In the optimal case, this would always work without problems. 
  However, if you see weird things, it might be because some non-standard things have been added to explanatory.ini or it has been majorly restructured. In either case, please let us know so we can update this documentation.
  You can always have a look at the underlying file :ref:`eplanatory.ini <https://github.com/lesgourg/class_public/blob/master/explanatory.ini>`_.

Detailed list of input parameters
---------------------------------

This section will be auto-generated by the custom python script!
"""
  conversion = convert_explanatory_function(fc)
  return pretext+"".join(conversion)

    
  
  
def convert_explanatory_function(custom_content_string):
    """
    Converts the custom content string into a list of reStructuredText chunks.
    Processes lines sequentially, identifying headers (now with 3-line pattern),
    then comment-example blocks.
    """
    rst_chunks = []
    content_lines = custom_content_string.splitlines()

    # Regex patterns (compile once for efficiency)
    # New header component patterns:
    header_separator_pattern = re.compile(r'^\s*#\s*-{3,}\s*$') # At least 3 dashes
    header_title_line_pattern = re.compile(r'^\s*#\s*-+>\s*(.*?)\s*[:]?\s*$', re.IGNORECASE)

    # Other patterns remain the same for now
    comment_block_start_pattern = re.compile(r'^\s*#\s*(\d+(\.\w+)*)\)\s+(.*)$')
    # commented_parameter_pattern is less critical now, as '=' is the primary differentiator for examples
    # commented_parameter_pattern = re.compile(r'^\s*#\s?[a-zA-Z_][a-zA-Z0-9_]*\s*=.*$')


    # State variables
    in_comment_block = False # True if collecting description lines
    current_comment_lines = []
    current_example_lines = []

    def finalize_current_block():
        """Helper to format and append the current comment/example block."""
        nonlocal in_comment_block, current_comment_lines, current_example_lines
        if current_comment_lines or current_example_lines:
            rst_chunks.append(format_comment_block_as_rst_list_item(current_comment_lines, current_example_lines))
            current_comment_lines = []
            current_example_lines = []
        in_comment_block = False # Ensure this is always reset after finalizing

    # --- Find the start index for actual processing based on the *first* header ---
    start_processing_index = 0
    first_header_found_sequence = False
    i = 0
    while i < len(content_lines) - 2: # Need at least 3 lines to detect a header sequence
        line1 = content_lines[i].strip()
        line2 = content_lines[i+1].strip()
        line3 = content_lines[i+2].strip()

        if (header_separator_pattern.match(line1) and
            header_title_line_pattern.match(line2) and
            header_separator_pattern.match(line3)):
            
            start_processing_index = i # Start from the first line of this header
            first_header_found_sequence = True
            break
        i += 1
    
    if not first_header_found_sequence:
        print("Warning: No complete 3-line header sequence found in the file. Processing all content or returning empty if no relevant content.")
        # If you truly want to skip EVERYTHING before the first header, even if no header:
        # return [] # Uncomment this if that's the desired behavior.
        # Else, start_processing_index remains 0 and we process everything.


    # Iterate through lines, starting from the first header (or beginning if no header sequence)
    # We will manually manage the index `idx` to skip lines when a header is found.
    idx = start_processing_index
    while idx < len(content_lines):
        line = content_lines[idx]
        stripped_line = line.strip()

        # 1) Check if it's a HEADER (highest priority, always ends previous block)
        # We need to check for the 3-line sequence again here for *subsequent* headers.
        if (idx + 2 < len(content_lines) and # Ensure there are 2 more lines to check
            header_separator_pattern.match(stripped_line) and # Current line is first separator
            header_title_line_pattern.match(content_lines[idx+1].strip()) and # Next is title
            header_separator_pattern.match(content_lines[idx+2].strip())): # Third is second separator
            
            finalize_current_block() # Finalize any preceding comment/example block

            header_title_match = header_title_line_pattern.match(content_lines[idx+1].strip())
            general_header_title = header_title_match.group(1).strip()
            underline = "^" * len(general_header_title)
            rst_chunks.append(general_header_title + "\n")
            rst_chunks.append(underline + "\n\n")
            
            idx += 3 # Skip all three header lines
            continue # Move to the next line after the header

        # Check for presence of '=' sign (relevant for examples)
        has_equals_sign = '=' in line # Use original line for this check

        # Check if line starts with '#' (relevant for all comments)
        starts_with_hash = stripped_line.startswith('#')

        # Check if it's a new comment block START (e.g., # 1) Description)
        start_comment_match = comment_block_start_pattern.match(stripped_line)


        # Now, apply the rules based on the current state and line type

        if start_comment_match:
            # 2) It's a new comment block start (e.g., # 1) Description)
            finalize_current_block() # Finalize any previous comment/example block
            in_comment_block = True
            clean_content = start_comment_match.group(3).strip()
            current_comment_lines.append(f"{start_comment_match.group(1)}) {clean_content}")
            
        elif has_equals_sign:
            # 3) It's an example line (contains '=')
            # If we were in a description block, this means the description ended and examples begin
            if in_comment_block:
                in_comment_block = False # Transition from description to example collection

            current_example_lines.append(line.strip()) # Add the line as an example
            
        elif starts_with_hash:
            # It's a general comment line (`#`, `# single_space`, `#  two_spaces`)
            # AND it's NOT a header, NOT a new comment block start.
            # So, it MUST be a continuation of a comment description.
            if in_comment_block:
                clean_content = re.sub(r'^\s*#\s*', '', line)
                current_comment_lines.append(clean_content)
            # else: If not in_comment_block, and it's just a general comment, ignore for now (separator)
            # This handles lines like `# Single # line` outside of a block.
        else:
            # If none of the above conditions met, this line acts as a block terminator
            # (e.g., blank lines, regular code lines that don't have '=').
            finalize_current_block() # Finalize any preceding block

        idx += 1 # Manually increment index at the end of each loop iteration if not already skipped


    # After the loop, finalize any remaining active block
    finalize_current_block()

    return rst_chunks


def format_comment_block_as_rst_list_item(comment_lines, example_lines):
    """
    Formats a list of cleaned comment lines into an RST bullet list item,
    and appends parameter example lines as a code-block.
    Returns a single RST string for this block.
    """
    rst_formatted_lines = []

    # Handle case where only example lines exist (orphaned)
    if not comment_lines and example_lines:
        print("Warning: Example lines found without a preceding comment. Formatting as standalone code block.")
        rst_formatted_lines.append(".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_lines.append("   " + example_line + "\n")
        rst_formatted_lines.append("\n") # Blank line after the code block
        return "".join(rst_formatted_lines)

    # If there are comment lines, format them as a bullet list
    if comment_lines:
        first_line_content = comment_lines[0]
        rst_formatted_lines.append("* " + first_line_content.strip() + "\n")

        indent_len = 4 # Standard indent for subsequent lines of list item text
        for line in comment_lines[1:]:
            rst_formatted_lines.append(" " * indent_len + line + "\n")

    # Append example lines as a code-block (if any)
    if example_lines:
        # Add a blank line for separation before the code block if there was previous content
        if comment_lines: # Only if there was an associated comment
             rst_formatted_lines.append("\n")

        code_block_indent = " " * (indent_len + 2) # e.g., 6 spaces for code blocks within list items or standalone

        rst_formatted_lines.append(code_block_indent + ".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_lines.append(code_block_indent + "   " + example_line + "\n") # 3 more spaces for code block content indent

    rst_formatted_lines.append("\n") # Blank line after the entire block for separation

    return "".join(rst_formatted_lines)

