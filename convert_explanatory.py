import re
# Input = file content (fc) as a big string
# Output = finished, polished .rst file to be directly included
def convert_explanatory(fc):
  # For now, just return dummy input independently of file contents, TODO:: implement actual logic
  pretext =  """.. _wrapper-set:

The .set() function
===================

.. function:: set(input)

  Tell classy to use certain input parameters, described in the python dictionary ``input``.
  Can also be passed as explicit keywords

  :param input: Input parameters
  :type input: dict

.. note::
  This documentation is based off of the contents of explanatory.ini and is automatically generated. In the optimal case, this would always work without problems. 
  However, if you see weird things, it might be because some non-standard things have been added to explanatory.ini or it has been majorly restructured. In either case, please let us know so we can update this documentation.
  You can always have a look at the underlying file :ref:`eplanatory.ini <https://github.com/lesgourg/class_public/blob/master/explanatory.ini>`_.

Detailed list of input parameters
---------------------------------

This section will be auto-generated by the custom python script! If you see this, the python script probably failed, please report to the developers!
"""
  conversion = convert_explanatory_function(fc)
  return pretext+"".join(conversion)

    
  
def convert_explanatory_function(custom_content_string):
    """
    Converts the custom content string into a list of reStructuredText chunks.
    Processes lines sequentially, identifying headers, then comment-example blocks.
    """
    rst_chunks = []
    content_lines = custom_content_string.splitlines()

    # Regex patterns (compile once for efficiency)
    header_pattern = re.compile(r'^\s*#\s*-+>\s*(.*?)\s*[:]?\s*$', re.IGNORECASE)
    comment_block_start_pattern = re.compile(r'^\s*#\s*(\d+(\.\w+)*)\)\s+(.*)$')
    commented_parameter_pattern = re.compile(r'^\s*#\s?[a-zA-Z_][a-zA-Z0-9_]*\s*=.*$')

    # State variables
    in_comment_block = False # True if collecting description lines
    current_comment_lines = []
    current_example_lines = []

    # --- Find the start index for actual processing ---
    start_processing_index = 0
    first_header_found = False
    for i, line in enumerate(content_lines):
        if header_pattern.match(line.strip()):
            start_processing_index = i # Start from this header line
            first_header_found = True
            break

    if not first_header_found:
        print("Warning: No header found in the file. Processing all content or returning empty if no relevant content.")
        print("Probably this is a bug! Please report to developers if you see this.")

    def finalize_current_block():
        """Helper to format and append the current comment/example block."""
        nonlocal in_comment_block, current_comment_lines, current_example_lines
        if current_comment_lines or current_example_lines:
            rst_chunks.append(format_comment_block_as_rst_list_item(current_comment_lines, current_example_lines))
            current_comment_lines = []
            current_example_lines = []
        in_comment_block = False # Ensure this is always reset after finalizing

    # Iterate through all lines
    for line_num, line in enumerate(content_lines[start_processing_index:]):
        stripped_line = line.strip()

        # 1) Check if it's a HEADER (highest priority, always ends previous block)
        header_match = header_pattern.match(stripped_line)
        if header_match:
            finalize_current_block() # Finalize any preceding comment/example block

            general_header_title = header_match.group(1).strip()
            underline = "=" * len(general_header_title)
            rst_chunks.append(general_header_title + "\n")
            rst_chunks.append(underline + "\n\n")
            continue # Move to the next line

        # Check for presence of '=' sign (relevant for examples)
        has_equals_sign = '=' in line # Use original line for this check

        # Check if line starts with '#' (relevant for all comments)
        starts_with_hash = stripped_line.startswith('#')

        # Check if it's a new comment block START (e.g., # 1) Description)
        start_comment_match = comment_block_start_pattern.match(stripped_line)

        # Check if it's a commented parameter line (e.g., #param = value)
        is_commented_parameter_line = commented_parameter_pattern.match(stripped_line)


        # Now, apply the rules based on the current state and line type

        if start_comment_match:
            # 2) It's a new comment block start (e.g., # 1) Description)
            finalize_current_block() # Finalize any previous comment/example block
            in_comment_block = True
            clean_content = start_comment_match.group(3).strip()
            current_comment_lines.append(f"{start_comment_match.group(1)}) {clean_content}")
            continue

        elif has_equals_sign:
            # 3) It's an example line (contains '=')
            # If we were in a description block, this means the description ended and examples begin
            if in_comment_block:
                in_comment_block = False # Transition from description to example collection

            current_example_lines.append(line.strip()) # Add the line as an example
            continue

        elif starts_with_hash:
            # It's a general comment line (`#`, `# single_space`, `#  two_spaces`)
            # AND it's NOT a header, NOT a new comment block start, NOT a parameter line.
            # So, it MUST be a continuation of a comment description.
            if in_comment_block:
                clean_content = re.sub(r'^\s*#\s*', '', line)
                current_comment_lines.append(clean_content)
                continue
            # else: If not in_comment_block, and it's just a general comment, ignore for now (separator)
            # This handles lines like `# Single # line` outside of a block.

        # If none of the above conditions met, this line acts as a block terminator
        # (e.g., blank lines, regular code lines that don't have '=').
        finalize_current_block() # Finalize any preceding block


    # After the loop, finalize any remaining active block
    finalize_current_block()

    return rst_chunks

    
def format_comment_block_as_rst_list_item(comment_lines, example_lines):
    """
    Formats a list of cleaned comment lines into an RST bullet list item,
    and appends parameter example lines as a code-block.
    Returns a single RST string for this block.
    """
    rst_formatted_lines = []

    # Handle case where only example lines exist (orphaned)
    if not comment_lines and example_lines:
        # print("Warning: Example lines found without a preceding comment. Formatting as standalone code block.")
        rst_formatted_lines.append(".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_lines.append("   " + example_line + "\n")
        rst_formatted_lines.append("\n") # Blank line after the code block
        return "".join(rst_formatted_lines)

    # If there are comment lines, format them as a bullet list
    if comment_lines:
        first_line_content = comment_lines[0]
        rst_formatted_lines.append("* " + first_line_content.strip() + "\n")

        indent_len = 4 # Standard indent for subsequent lines of list item text
        for line in comment_lines[1:]:
            rst_formatted_lines.append(" " * indent_len + line + "\n")

    # Append example lines as a code-block (if any)
    if example_lines:
        # Add a blank line for separation before the code block if there was previous content
        if comment_lines: # Only if there was an associated comment
             rst_formatted_lines.append("\n")

        code_block_indent = " " * (indent_len + 2) # e.g., 6 spaces for code blocks within list items or standalone

        rst_formatted_lines.append(code_block_indent + ".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_lines.append(code_block_indent + "   " + example_line + "\n") # 3 more spaces for code block content indent

    rst_formatted_lines.append("\n") # Blank line after the entire block for separation

    return "".join(rst_formatted_lines)
