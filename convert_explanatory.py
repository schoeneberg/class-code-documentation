import re
# Input = file content (fc) as a big string
# Output = finished, polished .rst file to be directly included
def convert_explanatory(fc):
  # For now, just return dummy input independently of file contents, TODO:: implement actual logic
  pretext =  """.. _wrapper-set:

The .set() function
===================

.. function:: set(input)

  Tell classy to use certain input parameters, described in the python dictionary ``input``.
  Can also be passed as explicit keywords

  :param input: Input parameters
  :type input: dict

.. note::
  This documentation is based off of the contents of explanatory.ini and is automatically generated. In the optimal case, this would always work without problems. 
  However, if you see weird things, it might be because some non-standard things have been added to explanatory.ini or it has been majorly restructured. In either case, please let us know so we can update this documentation.
  You can always have a look at the underlying file `eplanatory.ini <https://github.com/lesgourg/class_public/blob/master/explanatory.ini>`_ .

Detailed list of input parameters
---------------------------------

This section will be auto-generated by the custom python script!\n
"""
  conversion = convert_explanatory_function(fc)
  return pretext+"".join(conversion)

    
  
def convert_explanatory_function(custom_content_string):
    """
    Converts the custom content string into a list of reStructuredText chunks.
    Processes lines sequentially, identifying headers (now with 3-line pattern),
    then comment-example blocks.
    """
    rst_chunks = []
    content_lines = custom_content_string.splitlines()

    # Regex patterns (compile once for efficiency)
    # New header component patterns:
    header_separator_pattern = re.compile(r'^\s*#\s*-{3,}\s*$') # At least 3 dashes
    header_title_line_pattern = re.compile(r'^\s*#\s*-+>\s*(.*?)\s*[:]?\s*$', re.IGNORECASE)

    # Other patterns remain the same for now
    comment_block_start_pattern = re.compile(r'^\s*#\s*(\d+(\.\w+)*)\)\s+(.*)$')
    # commented_parameter_pattern is less critical now, as '=' is the primary differentiator for examples
    # commented_parameter_pattern = re.compile(r'^\s*#\s?[a-zA-Z_][a-zA-Z0-9_]*\s*=.*$')


    # State variables
    in_comment_block = False # True if collecting description lines
    current_comment_lines = []
    current_example_lines = []

    def finalize_current_block():
        """Helper to format and append the current comment/example block."""
        nonlocal in_comment_block, current_comment_lines, current_example_lines
        if current_comment_lines or current_example_lines:
            rst_chunks.append(format_comment_block_as_rst_list_item(current_comment_lines, current_example_lines))
            current_comment_lines = []
            current_example_lines = []
        in_comment_block = False # Ensure this is always reset after finalizing

    # --- Find the start index for actual processing based on the *first* header ---
    start_processing_index = 0
    first_header_found_sequence = False
    i = 0
    while i < len(content_lines) - 2: # Need at least 3 lines to detect a header sequence
        line1 = content_lines[i].strip()
        line2 = content_lines[i+1].strip()
        line3 = content_lines[i+2].strip()

        if (header_separator_pattern.match(line1) and
            header_title_line_pattern.match(line2) and
            header_separator_pattern.match(line3)):
            
            start_processing_index = i # Start from the first line of this header
            first_header_found_sequence = True
            break
        i += 1
    
    if not first_header_found_sequence:
        print("Warning: No complete 3-line header sequence found in the file. Processing all content or returning empty if no relevant content.")
        # If you truly want to skip EVERYTHING before the first header, even if no header:
        # return [] # Uncomment this if that's the desired behavior.
        # Else, start_processing_index remains 0 and we process everything.


    # Iterate through lines, starting from the first header (or beginning if no header sequence)
    # We will manually manage the index `idx` to skip lines when a header is found.
    idx = start_processing_index
    while idx < len(content_lines):
        line = content_lines[idx]
        stripped_line = line.strip()

        # 1) Check if it's a HEADER (highest priority, always ends previous block)
        # We need to check for the 3-line sequence again here for *subsequent* headers.
        if (idx + 2 < len(content_lines) and # Ensure there are 2 more lines to check
            header_separator_pattern.match(stripped_line) and # Current line is first separator
            header_title_line_pattern.match(content_lines[idx+1].strip()) and # Next is title
            header_separator_pattern.match(content_lines[idx+2].strip())): # Third is second separator
            
            finalize_current_block() # Finalize any preceding comment/example block

            header_title_match = header_title_line_pattern.match(content_lines[idx+1].strip())
            general_header_title = header_title_match.group(1).strip()
            underline = "^" * len(general_header_title)
            rst_chunks.append(general_header_title + "\n")
            rst_chunks.append(underline + "\n\n")
            
            idx += 3 # Skip all three header lines
            continue # Move to the next line after the header

        # Check for presence of '=' sign (relevant for examples)
        is_example_line = ('=' in line) and not line.lstrip().startswith("# ")

        # Check if line starts with '#' (relevant for all comments)
        starts_with_hash = stripped_line.startswith('#')

        # Check if it's a new comment block START (e.g., # 1) Description)
        start_comment_match = comment_block_start_pattern.match(stripped_line)


        # Now, apply the rules based on the current state and line type

        if start_comment_match:
            # 2) It's a new comment block start (e.g., # 1) Description)
            finalize_current_block() # Finalize any previous comment/example block
            in_comment_block = True
            label = start_comment_match.group(1) # e.g., '1.m'
            description_text = start_comment_match.group(3) # e.g., 'Do you want a warning...'

            escaped_first_line = f"{label}) {description_text}"
            current_comment_lines.append(escaped_first_line)

        elif is_example_line:
            # 3) It's an example line (contains '=')
            # If we were in a description block, this means the description ended and examples begin
            if in_comment_block:
                in_comment_block = False # Transition from description to example collection

            current_example_lines.append(line.strip()) # Add the line as an example
            
        elif starts_with_hash:
            # It's a general comment line (`#`, `# single_space`, `#  two_spaces`)
            # AND it's NOT a header, NOT a new comment block start.
            # So, it MUST be a continuation of a comment description.
            if in_comment_block:
                clean_content = re.sub(r'^\s*#\s*', '', line)
                current_comment_lines.append(clean_content)
            # else: If not in_comment_block, and it's just a general comment, ignore for now (separator)
            # This handles lines like `# Single # line` outside of a block.
        else:
            # If none of the above conditions met, this line acts as a block terminator
            # (e.g., blank lines, regular code lines that don't have '=').
            finalize_current_block() # Finalize any preceding block

        idx += 1 # Manually increment index at the end of each loop iteration if not already skipped


    # After the loop, finalize any remaining active block
    finalize_current_block()

    return rst_chunks



def format_comment_block_as_rst_list_item(comment_lines, example_lines):
    """
    Formats a list of cleaned comment lines into an RST bullet list item,
    and appends parameter example lines as a code-block.
    Returns a single RST string for this block.
    """
    rst_formatted_output = []

    # Handle case where only example lines exist (orphaned)
    if not comment_lines and example_lines:
        print("Warning: Example lines found without a preceding comment. Formatting as standalone code block.")
        rst_formatted_output.append(".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_output.append("   " + example_line + "\n")
        rst_formatted_output.append("\n")
        return "".join(rst_formatted_output)

    # If there are comment lines, format them as a bullet list
    if comment_lines:
        # Determine the initial indent for the line-block directive
        # The line-block directive itself needs to be indented relative to the bullet.
        # Bullet: "* " (2 spaces)
        # Line block directive: ".. line-block::" (14 chars)
        # So it needs to be indented by 2 spaces from the bullet.
        # Total indent for ".. line-block::" from left margin is 2 (for bullet) + 2 (for directive indent) = 4 spaces.
        line_block_directive_indent = " " * 4 

        # The content of the line-block starts with a '| ' (2 chars)
        # It's usually indented by 0 spaces relative to the line-block directive.
        # So the actual text starts 4 + 2 = 6 spaces from the left margin.
        line_block_content_indent = line_block_directive_indent # Same indent as directive for content's pipe


        # Start the bullet list item
        rst_formatted_output.append("* \n") # Start the bullet, then newline to put line-block on next line

        # Add the line-block directive itself, indented
        rst_formatted_output.append(line_block_directive_indent + ".. line-block::\n")
        rst_formatted_output.append("\n") # Blank line after directive (standard practice)

        # Add each comment line as a line in the line-block
        # Each line needs to start with '| ' and then be indented relative to the directive.
        # The content will start after the '| '
        for i, line in enumerate(comment_lines):
            # For the first line, just prepend '| '
            # For subsequent lines, if they were meant to be new paragraphs in the source (e.g., blank lines,
            # or significantly different indentation), we want to preserve that by making them new lines in the line-block.
            # We strip the line content to normalize, then add '| ' and our desired indent.
            
            # If the original source line was e.g. `#    Text`, after `re.sub(r'^\s*#\s*', '', line)` it became `   Text`.
            # We need to preserve that leading indent within the line-block if it was intentional.
            
            # Let's try to remove all leading spaces and then just prepend our standard `| `
            # to make it clean. If original indentation was crucial within the prose, we can adjust.
            clean_line_content = line.lstrip() # Remove any leading spaces from our pre-processed line

            # If it's a blank line from source, just add an indented blank line within the line-block
            if clean_line_content == '':
                rst_formatted_output.append(line_block_content_indent + "|\n") # Blank line within line-block
            else:
                rst_formatted_output.append(line_block_content_indent + "| " + clean_line_content + "\n")

    # Append example lines as a code-block (if any)
    if example_lines:
        # Add a blank line for separation before the code block if there were comments AND
        # if the line-block just ended (i.e., not already a blank line)
        if comment_lines and rst_formatted_output and rst_formatted_output[-1].strip() != "":
            rst_formatted_output.append("\n")

        # Code block indent needs to be consistent and deep enough.
        # A common practice is 6 spaces total (bullet + directive indent + 2).
        code_block_indent = " " * 6 

        rst_formatted_output.append(code_block_indent + ".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_output.append(code_block_indent + "   " + example_line + "\n")

    rst_formatted_output.append("\n") # Blank line after the entire block for separation

    return "".join(rst_formatted_output)

