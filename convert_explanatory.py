import re
# Input = file content (fc) as a big string
# Output = finished, polished .rst file to be directly included
def convert_explanatory(fc):
  # For now, just return dummy input independently of file contents, TODO:: implement actual logic
  pretext =  """.. _wrapper-set:

The .set() function
===================

.. function:: set(input)

  Tell classy to use certain input parameters, described in the python dictionary ``input``.
  Can also be passed as explicit keywords

  :param input: Input parameters
  :type input: dict

.. note::
  This documentation is based off of the contents of explanatory.ini and is automatically generated. In the optimal case, this would always work without problems. 
  However, if you see weird things, it might be because some non-standard things have been added to explanatory.ini or it has been majorly restructured. In either case, please let us know so we can update this documentation.
  You can always have a look at the underlying file :ref:`eplanatory.ini <https://github.com/lesgourg/class_public/blob/master/explanatory.ini>`_.

Detailed list of input parameters
---------------------------------

This section will be auto-generated by the custom python script!\n
"""
  conversion = convert_explanatory_function(fc)
  return pretext+"".join(conversion)

    
  
  
def convert_explanatory_function(custom_content_string):
    """
    Converts the custom content string into a list of reStructuredText chunks.
    Processes lines sequentially, identifying headers (now with 3-line pattern),
    then comment-example blocks.
    """
    rst_chunks = []
    content_lines = custom_content_string.splitlines()

    # Regex patterns (compile once for efficiency)
    # New header component patterns:
    header_separator_pattern = re.compile(r'^\s*#\s*-{3,}\s*$') # At least 3 dashes
    header_title_line_pattern = re.compile(r'^\s*#\s*-+>\s*(.*?)\s*[:]?\s*$', re.IGNORECASE)

    # Other patterns remain the same for now
    comment_block_start_pattern = re.compile(r'^\s*#\s*(\d+(\.\w+)*)\)\s+(.*)$')
    # commented_parameter_pattern is less critical now, as '=' is the primary differentiator for examples
    # commented_parameter_pattern = re.compile(r'^\s*#\s?[a-zA-Z_][a-zA-Z0-9_]*\s*=.*$')


    # State variables
    in_comment_block = False # True if collecting description lines
    current_comment_lines = []
    current_example_lines = []

    def finalize_current_block():
        """Helper to format and append the current comment/example block."""
        nonlocal in_comment_block, current_comment_lines, current_example_lines
        if current_comment_lines or current_example_lines:
            rst_chunks.append(format_comment_block_as_rst_list_item(current_comment_lines, current_example_lines))
            current_comment_lines = []
            current_example_lines = []
        in_comment_block = False # Ensure this is always reset after finalizing

    # --- Find the start index for actual processing based on the *first* header ---
    start_processing_index = 0
    first_header_found_sequence = False
    i = 0
    while i < len(content_lines) - 2: # Need at least 3 lines to detect a header sequence
        line1 = content_lines[i].strip()
        line2 = content_lines[i+1].strip()
        line3 = content_lines[i+2].strip()

        if (header_separator_pattern.match(line1) and
            header_title_line_pattern.match(line2) and
            header_separator_pattern.match(line3)):
            
            start_processing_index = i # Start from the first line of this header
            first_header_found_sequence = True
            break
        i += 1
    
    if not first_header_found_sequence:
        print("Warning: No complete 3-line header sequence found in the file. Processing all content or returning empty if no relevant content.")
        # If you truly want to skip EVERYTHING before the first header, even if no header:
        # return [] # Uncomment this if that's the desired behavior.
        # Else, start_processing_index remains 0 and we process everything.


    # Iterate through lines, starting from the first header (or beginning if no header sequence)
    # We will manually manage the index `idx` to skip lines when a header is found.
    idx = start_processing_index
    while idx < len(content_lines):
        line = content_lines[idx]
        stripped_line = line.strip()

        # 1) Check if it's a HEADER (highest priority, always ends previous block)
        # We need to check for the 3-line sequence again here for *subsequent* headers.
        if (idx + 2 < len(content_lines) and # Ensure there are 2 more lines to check
            header_separator_pattern.match(stripped_line) and # Current line is first separator
            header_title_line_pattern.match(content_lines[idx+1].strip()) and # Next is title
            header_separator_pattern.match(content_lines[idx+2].strip())): # Third is second separator
            
            finalize_current_block() # Finalize any preceding comment/example block

            header_title_match = header_title_line_pattern.match(content_lines[idx+1].strip())
            general_header_title = header_title_match.group(1).strip()
            underline = "^" * len(general_header_title)
            rst_chunks.append(general_header_title + "\n")
            rst_chunks.append(underline + "\n\n")
            
            idx += 3 # Skip all three header lines
            continue # Move to the next line after the header

        # Check for presence of '=' sign (relevant for examples)
        has_equals_sign = '=' in line # Use original line for this check

        # Check if line starts with '#' (relevant for all comments)
        starts_with_hash = stripped_line.startswith('#')

        # Check if it's a new comment block START (e.g., # 1) Description)
        start_comment_match = comment_block_start_pattern.match(stripped_line)


        # Now, apply the rules based on the current state and line type

        if start_comment_match:
            # 2) It's a new comment block start (e.g., # 1) Description)
            finalize_current_block() # Finalize any previous comment/example block
            in_comment_block = True
            clean_content = start_comment_match.group(3).strip()
            current_comment_lines.append(f"{start_comment_match.group(1)}) {clean_content}")
            
        elif has_equals_sign:
            # 3) It's an example line (contains '=')
            # If we were in a description block, this means the description ended and examples begin
            if in_comment_block:
                in_comment_block = False # Transition from description to example collection

            current_example_lines.append(line.strip()) # Add the line as an example
            
        elif starts_with_hash:
            # It's a general comment line (`#`, `# single_space`, `#  two_spaces`)
            # AND it's NOT a header, NOT a new comment block start.
            # So, it MUST be a continuation of a comment description.
            if in_comment_block:
                clean_content = re.sub(r'^\s*#\s*', '', line)
                current_comment_lines.append(clean_content)
            # else: If not in_comment_block, and it's just a general comment, ignore for now (separator)
            # This handles lines like `# Single # line` outside of a block.
        else:
            # If none of the above conditions met, this line acts as a block terminator
            # (e.g., blank lines, regular code lines that don't have '=').
            finalize_current_block() # Finalize any preceding block

        idx += 1 # Manually increment index at the end of each loop iteration if not already skipped


    # After the loop, finalize any remaining active block
    finalize_current_block()

    return rst_chunks

def format_comment_block_as_rst_list_item(comment_lines, example_lines):
    """
    Formats a list of cleaned comment lines into an RST bullet list item,
    and appends parameter example lines as a code-block.
    Returns a single RST string for this block.
    """
    rst_formatted_output = []

    # Handle case where only example lines exist (orphaned)
    if not comment_lines and example_lines:
        print("Warning: Example lines found without a preceding comment. Formatting as standalone code block.")
        rst_formatted_output.append(".. code-block:: none\n\n")
        for example_line in example_lines:
            rst_formatted_output.append("   " + example_line + "\n")
        rst_formatted_output.append("\n")
        return "".join(rst_formatted_output)

    # If there are comment lines, format them as a bullet list
    if comment_lines:
        # The first line already contains the "1) " or "2.a) " part.
        # We'll use a bullet point for the list item itself.
        
        # Calculate the indent for continuation lines based on the first line's actual content.
        # 1. Start with the bullet indent (2 characters: "* ")
        bullet_indent = " " * 2 

        # 2. Add the content of the first line directly after the bullet.
        #    This `comment_lines[0]` should be "2) Amount of information..." (clean after stripping # )
        first_line_content = comment_lines[0]
        rst_formatted_output.append("* " + first_line_content + "\n")
 
        # 3. Determine the actual hanging indent required:
        #    It should be the length of the bullet_indent plus the length of the *label* part of the first line.
        #    E.g., for "* 2) Amount...", the hanging indent should be aligned with 'A'.
        #    If `first_line_content` is "2) Amount...", `len("2) ")` is 4.
        #    So, total indent for continuation lines should be `len(bullet_indent) + len("2) ")` = 2 + 4 = 6 spaces.
        #    However, RST standard usually recommends a consistent minimum indent, not necessarily aligning
        #    with the exact start of the content of the first line if it's too far.
        #    A standard choice that usually works well: `len("* ") + 2` or `len("* ") + len("1) ")`
        #    Let's stick with a fixed `4` as it's a common value for readability, but apply it carefully.
        #    If `comment_lines[0]` contains the numbering like '2)', we need the continuation lines
        #    to be indented such that they align with the *start of the descriptive text* following '2) '.
        
        # New approach: Figure out the length of the first line up to where the descriptive text starts.
        # E.g., for "2) Amount...", `prefix_len` would be `len("2) ")` = 4.
        # Total indent: `len("* ")` (2) + `prefix_len`.
        
        # Extract just the label part (e.g., "2)", "2.a)") from the first line
        label_match = re.match(r'^\s*(\d+(\.\w+)*)\)\s*(.*)$', first_line_content)
        if label_match:
            label_part = label_match.group(1) + ") " # e.g., "2) " or "2.a) "
            # Calculate the indent needed to align with the text after the label
            # = (length of bullet) + (length of label part)
            continuation_indent_len = len(bullet_indent) + len(label_part)
        else:
            # Fallback if no specific label like "2)" is found (shouldn't happen with current logic)
            continuation_indent_len = 4 # Default to 4 spaces

        continuation_indent = " " * continuation_indent_len 

        for line in comment_lines[1:]:
            # If a line is empty after stripping (e.g., from `#` in source),
            # it should become an indented blank line to maintain RST paragraph flow.
            if line.strip() == '':
                rst_formatted_output.append(continuation_indent + "\n") # Indent a blank line
            else:
                # Append with the hanging indent. `line` already has its `# ` stripped.
                rst_formatted_output.append(continuation_indent + line.strip() + "\n")


    # Append example lines as a code-block (if any)
    if example_lines:
        # Add a blank line for separation before the code block IF there were comment lines,
        # AND if the previous line wasn't already a blank line (to avoid double blanks).
        if comment_lines and not rst_formatted_output[-1].strip(): # check if last line was effectively blank (e.g. from an empty comment line)
            pass # No need for extra blank line, one already exists
        elif comment_lines: # If there were comments, add a blank line for separation
             rst_formatted_output.append("\n")

        # The code block needs to be indented relative to the bullet item.
        # Bullet `* ` is 2 chars. `first_line_of_item` starts after that.
        # A code block inside a list item needs to be at least indented by `len(bullet) + 1` space.
        # A common practice is 6 spaces total (4 for bullet indent + 2 for code block).
        code_block_indent = " " * 6

        rst_formatted_output.append(code_block_indent + ".. code-block:: none\n\n")
        for example_line in example_lines:
            # Code block content is indented by 3 more spaces from the code-block directive.
            rst_formatted_output.append(code_block_indent + "   " + example_line + "\n")

    rst_formatted_output.append("\n") # Blank line after the entire block for separation

    return "".join(rst_formatted_output)

